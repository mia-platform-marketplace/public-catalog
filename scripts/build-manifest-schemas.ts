/**
 * Copyright 2025 Mia srl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs/promises'
import path from 'node:path'

import { catalogWellKnownItems, catalogItemManifestSchema } from '@mia-platform/console-types'
import type { JSONSchema } from 'json-schema-to-ts'
import { JSONPath } from 'jsonpath-plus'
import { cloneDeep, get, set, unset } from 'lodash-es'

import categories from '../assets/categories.json' with { type: 'json' }
import supporters from '../assets/supporters.json' with { type: 'json' }

import logger from './lib/logger'
import type { ItemTypeModule } from './lib/utils'

const comment = 'This file was autogenerated, DO NOT modify it by hand.'
const defaultTenant = 'mia-platform'

const categoryIdSchema: JSONSchema = {
  enum: categories.categories.map(({ categoryId }) => categoryId),
  type: 'string',
}

const imageSchema: JSONSchema = {
  additionalProperties: false,
  properties: {
    localPath: { type: 'string' },
  },
  required: ['localPath'],
  type: 'object',
}

const supportedBySchema: JSONSchema = {
  enum: supporters.supporters.map(({ label }) => label),
  type: 'string',
}

const visibilitySchema: JSONSchema = {
  additionalProperties: false,
  properties: { public: { const: true } },
  required: ['public'],
  type: 'object',
}

/** @modifies Edits the input manifest */
const makeContainerPortsRequired = (manifest: object, type: string) => {
  const typesToPatch = [
    catalogWellKnownItems.application.type,
    catalogWellKnownItems.example.type,
    catalogWellKnownItems.plugin.type,
    catalogWellKnownItems.template.type,
  ]

  if (!typesToPatch.includes(type)) { return }

  const editRequired = (containerPortsPropPath: string) => {
    const arrayPath = containerPortsPropPath.split('/')
    const parentPath = arrayPath.slice(1, -1)

    // Skip plugin sidecars
    if (parentPath.includes('additionalContainers')) { return }

    const required = get(manifest, [...parentPath, 'required']) as string[] | undefined
    if (required) { required.push('containerPorts') }
  }

  JSONPath({
    callback: editRequired,
    json: manifest,
    // Find any object containing a property named "containerPorts"
    path: '$..[?(@.containerPorts)]',
    resultType: 'pointer',
  })
}

const requiredProps = [
  ...catalogItemManifestSchema.required,
  'categoryId',
  'image',
  'supportedBy',
  'supportedByImage',
  'visibility',
  'releaseDate',
]

const main = async () => {
  const typeDirs = await fs.readdir(path.resolve(process.cwd(), 'items'), { withFileTypes: true })

  for (const typeDirent of typeDirs) {
    if (!typeDirent.isDirectory()) { continue }

    const data = await import(path.resolve(typeDirent.parentPath, typeDirent.name)) as ItemTypeModule

    const typeData = cloneDeep(catalogWellKnownItems[data.default.type])
    if (!typeData) {
      throw new Error(`Directory '${typeDirent.name}' with items of type '${data.default.type}' does not correspond to any well-known catalog item type`)
    }

    const manifest = cloneDeep({ $comment: comment, ...catalogItemManifestSchema })

    set(manifest, ['$id'], `${typeData.type}-manifest.schema.json`)
    set(manifest, ['title'], `Manifest for items of type ${typeData.type}`)
    set(manifest, ['required'], requiredProps)
    unset(manifest, ['description'])

    set(manifest, ['properties', '$schema'], { type: 'string' })
    set(manifest, ['properties', 'categoryId'], categoryIdSchema)
    set(manifest, ['properties', 'supportedBy'], supportedBySchema)
    set(manifest, ['properties', 'resources'], typeData.resourcesSchema)
    set(manifest, ['properties', 'tenantId'], { const: defaultTenant })
    set(manifest, ['properties', 'type'], { const: typeData.type })
    set(manifest, ['properties', 'visibility'], visibilitySchema)
    unset(manifest, ['properties', 'isVersioningSupported'])

    set(manifest, ['properties', 'image'], imageSchema)
    unset(manifest, ['properties', 'imageUrl'])

    set(manifest, ['properties', 'supportedByImage'], imageSchema)
    unset(manifest, ['properties', 'supportedByImageUrl'])

    set(manifest, ['properties', 'resources', 'description'], 'Assets used by Mia-Platform Console to create the item')
    unset(manifest, ['properties', 'resources', '$id'])
    unset(manifest, ['properties', 'resources', '$schema'])
    unset(manifest, ['properties', 'resources', 'title'])

    makeContainerPortsRequired(manifest, typeData.type)

    await fs.writeFile(
      path.resolve(typeDirent.parentPath, typeDirent.name, 'manifest.schema.json'),
      `${JSON.stringify(manifest, null, 2)}\n`
    )
  }
}

main()
  .then(() => logger.success('Schemas compiled correctly'))
  .catch((...args) => logger.error('Error compiling schemas', ...args))

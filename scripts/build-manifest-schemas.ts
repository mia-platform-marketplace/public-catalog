/**
 * Copyright 2025 Mia srl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs/promises'
import path from 'node:path'

import { catalogWellKnownItems, catalogItemManifestSchema } from '@mia-platform/console-types'
import type { JSONSchema } from 'json-schema-to-ts'
import { cloneDeep, set, unset } from 'lodash-es'

import categories from '../assets/categories.json' with { type: 'json' }
import supporters from '../assets/supporters.json' with { type: 'json' }

import { logger } from './utils'

const comment = 'This file was autogenerated, DO NOT modify it by hand.'
const defaultTenant = 'mia-platform'

const main = async () => {
  const categoryIdSchema: JSONSchema = {
    enum: categories.categories.map(({ categoryId }) => categoryId),
    type: 'string',
  }

  const imageSchema: JSONSchema = {
    additionalProperties: false,
    properties: {
      localPath: { type: 'string' },
    },
    required: ['localPath'],
    type: 'object',
  }

  const supportedBySchema: JSONSchema = {
    enum: supporters.supporters.map(({ label }) => label),
    type: 'string',
  }

  const visibilitySchema: JSONSchema = {
    additionalProperties: false,
    properties: { public: { const: true } },
    required: ['public'],
    type: 'object',
  }

  const requiredProps = [
    ...catalogItemManifestSchema.required,
    'categoryId',
    'image',
    'supportedBy',
    'supportedByImage',
    'visibility',
  ]

  for (const itemData of Object.values(catalogWellKnownItems)) {
    const filename = `${itemData.type}-manifest.schema.json`

    const manifest = cloneDeep({ $comment: comment, ...catalogItemManifestSchema })

    set(manifest, ['$id'], filename)
    set(manifest, ['title'], `Manifest for items of type ${itemData.type}`)
    set(manifest, ['required'], requiredProps)
    unset(manifest, ['description'])

    set(manifest, ['properties', '$schema'], { type: 'string' })
    set(manifest, ['properties', 'categoryId'], categoryIdSchema)
    set(manifest, ['properties', 'supportedBy'], supportedBySchema)
    set(manifest, ['properties', 'resources'], itemData.resourcesSchema)
    set(manifest, ['properties', 'tenantId'], { const: defaultTenant })
    set(manifest, ['properties', 'type'], { const: itemData.type })
    set(manifest, ['properties', 'visibility'], visibilitySchema)
    unset(manifest, ['properties', 'isVersioningSupported'])

    set(manifest, ['properties', 'image'], imageSchema)
    unset(manifest, ['properties', 'imageUrl'])

    set(manifest, ['properties', 'supportedByImage'], imageSchema)
    unset(manifest, ['properties', 'supportedByImageUrl'])

    set(manifest, ['properties', 'resources', 'description'], 'Assets used by Mia-Platform Console to create the item')
    unset(manifest, ['properties', 'resources', '$id'])
    unset(manifest, ['properties', 'resources', '$schema'])
    unset(manifest, ['properties', 'resources', 'title'])

    await fs.writeFile(path.resolve(process.cwd(), 'schemas', filename), `${JSON.stringify(manifest, null, 2)}\n`)

    logger.success(`Compiled schema for ${itemData.type} items`)
  }
}

main()
  .catch((...args) => logger.error(...args))

/**
 * Copyright 2025 Mia srl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs/promises'
import path from 'node:path'

import type { CatalogWellKnownItemData } from '@mia-platform/console-types'
import { catalogWellKnownItems, catalogItemManifestSchema } from '@mia-platform/console-types'
import type { JSONSchema } from 'json-schema-to-ts'
import { JSONPath } from 'jsonpath-plus'
import { cloneDeep, get, set, unset } from 'lodash-es'

import categories from '../assets/categories.json' with { type: 'json' }
import supporters from '../assets/supporters.json' with { type: 'json' }

import logger from './lib/logger'

const comment = 'This file was autogenerated, DO NOT modify it by hand.'
const defaultTenant = 'mia-platform'

const categoryIdSchema: JSONSchema = {
  enum: categories.categories.map(({ categoryId }) => categoryId),
  type: 'string',
}

const imageSchema: JSONSchema = {
  additionalProperties: false,
  properties: {
    localPath: { type: 'string' },
  },
  required: ['localPath'],
  type: 'object',
}

const supportedBySchema: JSONSchema = {
  enum: supporters.supporters.map(({ label }) => label),
  type: 'string',
}

const visibilitySchema: JSONSchema = {
  additionalProperties: false,
  properties: { public: { const: true } },
  required: ['public'],
  type: 'object',
}

/** @modifies Edits the input manifest */
const makeContainerPortsRequired = (manifest: object, type: string) => {
  const typesToPatch = [
    catalogWellKnownItems.application.type,
    catalogWellKnownItems.example.type,
    catalogWellKnownItems.plugin.type,
    catalogWellKnownItems.template.type,
  ]

  if (!typesToPatch.includes(type)) { return }

  const editRequired = (containerPortsPropPath: string) => {
    const arrayPath = containerPortsPropPath.split('/')
    const parentPath = arrayPath.slice(1, -1)

    // Skip plugin sidecars
    if (parentPath.includes('additionalContainers')) { return }

    const required = get(manifest, [...parentPath, 'required']) as string[] | undefined
    if (required) { required.push('containerPorts') }
  }

  JSONPath({
    callback: editRequired,
    json: manifest,
    // Find any object containing a property named "containerPorts"
    path: '$..[?(@.containerPorts)]',
    resultType: 'pointer',
  })
}

const requiredProps = [
  ...catalogItemManifestSchema.required,
  'categoryId',
  'image',
  'supportedBy',
  'supportedByImage',
  'visibility',
  'releaseDate',
]

const buildManifestSchema = (itemData: CatalogWellKnownItemData): object => {
  const manifest = cloneDeep({ $comment: comment, ...catalogItemManifestSchema })

  set(manifest, ['$id'], `${itemData.type}-manifest.schema.json`)
  set(manifest, ['title'], `Manifest for items of type ${itemData.type}`)
  set(manifest, ['required'], requiredProps)
  unset(manifest, ['description'])

  set(manifest, ['properties', '$schema'], { type: 'string' })
  set(manifest, ['properties', 'categoryId'], categoryIdSchema)
  set(manifest, ['properties', 'supportedBy'], supportedBySchema)
  set(manifest, ['properties', 'resources'], itemData.resourcesSchema)
  set(manifest, ['properties', 'tenantId'], { const: defaultTenant })
  set(manifest, ['properties', 'type'], { const: itemData.type })
  set(manifest, ['properties', 'visibility'], visibilitySchema)

  set(manifest, ['properties', 'image'], imageSchema)
  unset(manifest, ['properties', 'imageUrl'])

  set(manifest, ['properties', 'supportedByImage'], imageSchema)
  unset(manifest, ['properties', 'supportedByImageUrl'])

  if (!itemData.crd.resources.isVersioningSupported) {
    unset(manifest, ['properties', 'version'])
  }

  set(manifest, ['properties', 'resources', 'description'], 'Assets used by Mia-Platform Console to create the item')
  unset(manifest, ['properties', 'resources', '$id'])
  unset(manifest, ['properties', 'resources', '$schema'])
  unset(manifest, ['properties', 'resources', 'title'])

  makeContainerPortsRequired(manifest, itemData.type)

  return manifest
}

const main = async () => {
  const itemsDirPath = path.resolve(process.cwd(), 'items')

  for (const wellKnownItemData of Object.values(catalogWellKnownItems)) {
    const typeDirPath = path.resolve(itemsDirPath, wellKnownItemData.type)

    await fs.mkdir(typeDirPath, { recursive: true })

    const manifestSchema = buildManifestSchema(cloneDeep(wellKnownItemData))
    await fs.writeFile(path.resolve(typeDirPath, 'manifest.schema.json'), `${JSON.stringify(manifestSchema, null, 2)}\n`)
  }
}

main()
  .then(() => logger.success('CRDs synched correctly'))
  .catch((...args) => logger.error('Error synching CRDs', ...args))
